% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregationFunction_EM.R,
%   R/aggregationFunction_bootLM.R, R/aggregationFunction_lm.R,
%   R/aggregationFunction_quantile.R, R/fitAggregationFunction.R
\name{fitAggregationFunction_EM}
\alias{fitAggregationFunction_EM}
\alias{predict.ModelAggregator_EM}
\alias{fitAggregationFunction_bootLM}
\alias{predict.ModelAggregator_bootLM}
\alias{fitAggregationFunction_lm}
\alias{predict.ModelAggregator_lm}
\alias{fitAggregationFunction_quantile}
\alias{predict.QuantileAggregation}
\alias{fitAggregationFunction}
\title{Fit Aggregation Function EM}
\usage{
fitAggregationFunction_EM(
  Y,
  y_hat,
  tol = 1e-04,
  max_iter = 1000,
  verbose = FALSE
)

\method{predict}{ModelAggregator_EM}(object, y_hat, alpha = 0.05, n_trials = 1000, ...)

fitAggregationFunction_bootLM(Y, y_hat, boot_iter = 1000, ...)

\method{predict}{ModelAggregator_bootLM}(object, y_hat, alpha = 0.05, ...)

fitAggregationFunction_lm(Y, y_hat, calibrate_sd = FALSE, ...)

\method{predict}{ModelAggregator_lm}(object, y_hat, alpha = 0.05, ...)

fitAggregationFunction_quantile(Y, y_hat, ...)

\method{predict}{QuantileAggregation}(object, y_hat, alpha = 0.05, ...)

fitAggregationFunction(Y, y_hat, method = "EM", ...)
}
\arguments{
\item{Y}{The true Y values for fitting}

\item{y_hat}{The predictions output from a model. Note that this is passed
as an \eqn{N \times K} matrix, where \eqn{K} is the number of predictors.}

\item{...}{Additional arguments to pass to the individual aggregation fitting methods. Each has their own
set of parameters for customizing the aggregation process according to the methodology
in the model.}

\item{boot_iter}{The number of bootstrap iterations to perform.}
}
\value{
A model aggregation object that contains metadata required for
predicting new values from a provided set of predictions.
}
\description{
High level general interface for fitting aggregations of regressor
variables into a single output prediction. The individual logic of aggregation
methods and their subsequent application to new data is handled by individual
fitting methods. S3 dispatch is used to determine the correct method
of prediction.

To add a new method, one should create a new file and define both the fitting
method and the prediction method. The fit method should output a unique S3 class
name, and by convention it should be `ModelAggregator_{method}`.
}
\section{Functions}{
\itemize{
\item \code{fitAggregationFunction_EM()}: Fit a Normal mixture model on the regressors using the EM algorithm

\item \code{predict(ModelAggregator_EM)}: Predict method for the S3 EM Model Aggregation function.

\item \code{fitAggregationFunction_bootLM()}: Fit a standard linear model to the data for aggregation.

\item \code{predict(ModelAggregator_bootLM)}: S3 prediction method for the bootLM aggregation function

\item \code{fitAggregationFunction_lm()}: Fit a standard linear model to the data for aggregation.

\item \code{predict(ModelAggregator_lm)}: predict method for the LM aggregation function

\item \code{fitAggregationFunction_quantile()}: Fit a quantile regression model to the data for aggregation.

\item \code{predict(QuantileAggregation)}: General S3 method for the quantile prediction method

}}
\examples{
\dontrun{
# Make three small test models for mixing
y_hat1 <- rnorm(1000, 3, 1)
y_hat2 <- rnorm(1000, 3, 1.5)
y_hat3 <- rnorm(1000, 3, 0.5)

y_hat <- cbind(y_hat1, y_hat2, y_hat3)

w <- c(0.5, 0.2, 0.3)
y <- (y_hat \%*\% w + rnorm(1000))[, 1]

model_aggregator <- fitAggregationFunction(y, y_hat, method="quantile")
predict(model_aggregator, y_hat, alpha=0.05)
}
}
